#!/user/bin/env python3
# -*- coding: utf-8 -*-
"""
它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。
在其实现过程使用双层循环，
外层循环对除了第一个元素之外的所有元素，
内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

基本思想：插入排序的工作原理是通过构建有序序列，在已排序序列中从后向前扫描，找到相应位置并插入。
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），
因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
"""


# 3，5，2，6

def insertion_sort(nums):
    """
    ① 从第一个元素开始，该元素可以认为已经被排序
    ② 取出下一个元素，在已经排序的元素序列中从后向前扫描
    ③如果该元素（已排序）大于新元素，将该元素移到下一位置
    ④ 重复步骤③，直到找到已排序的元素小于或者等于新元素的位置
    ⑤将新元素插入到该位置后
    ⑥ 重复步骤②~⑤
    :param nums:
    :return:
    """
    for i in range(1, len(nums)):
        cur = i
        for j in range(i-1, -1, -1):
            if nums[cur] < nums[j]:
                nums[cur], nums[j] = nums[j], nums[cur]
                cur -= 1
    return nums


print(insertion_sort([5, 4, 6, 3, 7, 2, 8, 1, 9]))
# 平均时间复杂度：O(N^2)
# 最差时间复杂度：O(N^2)
# 空间复杂度：O(1)
# 排序方式：In-place
# 稳定性：稳定
"""
如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：

(1) 最好情况：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。
(2) 最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。
插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(N^2)。

最优的空间复杂度为开始元素已排序，则空间复杂度为 0；

最差的空间复杂度为开始元素为逆排序，则空间复杂度最坏时为 O(N);

平均的空间复杂度为O(1)
"""